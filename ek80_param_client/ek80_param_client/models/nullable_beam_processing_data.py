# coding: utf-8

"""
    REST API for the EK80 Echo Sounder

    The API, and the documentation of it, is still under construction. Feel free to experiment with it, but Kongsberg is only able to provide very limited support at the moment.  # noqa: E501

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class NullableBeamProcessingData(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'directivity_drop_at_2x_beam_width': 'float',
        'equivalent_beam_angle': 'float',
        'impedance': 'float',
        'impedance_phase': 'float',
        'sa_correction': 'float',
        'angle_offset': 'AngleOffset',
        'angle_sensitivity': 'AngleSensitivity'
    }

    attribute_map = {
        'directivity_drop_at_2x_beam_width': 'directivity-drop-at-2x-beam-width',
        'equivalent_beam_angle': 'equivalent-beam-angle',
        'impedance': 'impedance',
        'impedance_phase': 'impedance-phase',
        'sa_correction': 'sa-correction',
        'angle_offset': 'angle-offset',
        'angle_sensitivity': 'angle-sensitivity'
    }

    def __init__(self, directivity_drop_at_2x_beam_width=None, equivalent_beam_angle=None, impedance=None, impedance_phase=None, sa_correction=None, angle_offset=None, angle_sensitivity=None):  # noqa: E501
        """NullableBeamProcessingData - a model defined in Swagger"""  # noqa: E501

        self._directivity_drop_at_2x_beam_width = None
        self._equivalent_beam_angle = None
        self._impedance = None
        self._impedance_phase = None
        self._sa_correction = None
        self._angle_offset = None
        self._angle_sensitivity = None
        self.discriminator = None

        if directivity_drop_at_2x_beam_width is not None:
            self.directivity_drop_at_2x_beam_width = directivity_drop_at_2x_beam_width
        if equivalent_beam_angle is not None:
            self.equivalent_beam_angle = equivalent_beam_angle
        if impedance is not None:
            self.impedance = impedance
        if impedance_phase is not None:
            self.impedance_phase = impedance_phase
        if sa_correction is not None:
            self.sa_correction = sa_correction
        if angle_offset is not None:
            self.angle_offset = angle_offset
        if angle_sensitivity is not None:
            self.angle_sensitivity = angle_sensitivity

    @property
    def directivity_drop_at_2x_beam_width(self):
        """Gets the directivity_drop_at_2x_beam_width of this NullableBeamProcessingData.  # noqa: E501


        :return: The directivity_drop_at_2x_beam_width of this NullableBeamProcessingData.  # noqa: E501
        :rtype: float
        """
        return self._directivity_drop_at_2x_beam_width

    @directivity_drop_at_2x_beam_width.setter
    def directivity_drop_at_2x_beam_width(self, directivity_drop_at_2x_beam_width):
        """Sets the directivity_drop_at_2x_beam_width of this NullableBeamProcessingData.


        :param directivity_drop_at_2x_beam_width: The directivity_drop_at_2x_beam_width of this NullableBeamProcessingData.  # noqa: E501
        :type: float
        """

        self._directivity_drop_at_2x_beam_width = directivity_drop_at_2x_beam_width

    @property
    def equivalent_beam_angle(self):
        """Gets the equivalent_beam_angle of this NullableBeamProcessingData.  # noqa: E501


        :return: The equivalent_beam_angle of this NullableBeamProcessingData.  # noqa: E501
        :rtype: float
        """
        return self._equivalent_beam_angle

    @equivalent_beam_angle.setter
    def equivalent_beam_angle(self, equivalent_beam_angle):
        """Sets the equivalent_beam_angle of this NullableBeamProcessingData.


        :param equivalent_beam_angle: The equivalent_beam_angle of this NullableBeamProcessingData.  # noqa: E501
        :type: float
        """

        self._equivalent_beam_angle = equivalent_beam_angle

    @property
    def impedance(self):
        """Gets the impedance of this NullableBeamProcessingData.  # noqa: E501


        :return: The impedance of this NullableBeamProcessingData.  # noqa: E501
        :rtype: float
        """
        return self._impedance

    @impedance.setter
    def impedance(self, impedance):
        """Sets the impedance of this NullableBeamProcessingData.


        :param impedance: The impedance of this NullableBeamProcessingData.  # noqa: E501
        :type: float
        """

        self._impedance = impedance

    @property
    def impedance_phase(self):
        """Gets the impedance_phase of this NullableBeamProcessingData.  # noqa: E501


        :return: The impedance_phase of this NullableBeamProcessingData.  # noqa: E501
        :rtype: float
        """
        return self._impedance_phase

    @impedance_phase.setter
    def impedance_phase(self, impedance_phase):
        """Sets the impedance_phase of this NullableBeamProcessingData.


        :param impedance_phase: The impedance_phase of this NullableBeamProcessingData.  # noqa: E501
        :type: float
        """

        self._impedance_phase = impedance_phase

    @property
    def sa_correction(self):
        """Gets the sa_correction of this NullableBeamProcessingData.  # noqa: E501


        :return: The sa_correction of this NullableBeamProcessingData.  # noqa: E501
        :rtype: float
        """
        return self._sa_correction

    @sa_correction.setter
    def sa_correction(self, sa_correction):
        """Sets the sa_correction of this NullableBeamProcessingData.


        :param sa_correction: The sa_correction of this NullableBeamProcessingData.  # noqa: E501
        :type: float
        """

        self._sa_correction = sa_correction

    @property
    def angle_offset(self):
        """Gets the angle_offset of this NullableBeamProcessingData.  # noqa: E501


        :return: The angle_offset of this NullableBeamProcessingData.  # noqa: E501
        :rtype: AngleOffset
        """
        return self._angle_offset

    @angle_offset.setter
    def angle_offset(self, angle_offset):
        """Sets the angle_offset of this NullableBeamProcessingData.


        :param angle_offset: The angle_offset of this NullableBeamProcessingData.  # noqa: E501
        :type: AngleOffset
        """

        self._angle_offset = angle_offset

    @property
    def angle_sensitivity(self):
        """Gets the angle_sensitivity of this NullableBeamProcessingData.  # noqa: E501


        :return: The angle_sensitivity of this NullableBeamProcessingData.  # noqa: E501
        :rtype: AngleSensitivity
        """
        return self._angle_sensitivity

    @angle_sensitivity.setter
    def angle_sensitivity(self, angle_sensitivity):
        """Sets the angle_sensitivity of this NullableBeamProcessingData.


        :param angle_sensitivity: The angle_sensitivity of this NullableBeamProcessingData.  # noqa: E501
        :type: AngleSensitivity
        """

        self._angle_sensitivity = angle_sensitivity

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(NullableBeamProcessingData, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, NullableBeamProcessingData):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
