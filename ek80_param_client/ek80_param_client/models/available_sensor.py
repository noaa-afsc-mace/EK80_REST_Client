# coding: utf-8

"""
    REST API for the EK80 Echo Sounder

    The API, and the documentation of it, is still under construction. Feel free to experiment with it, but Kongsberg is only able to provide very limited support at the moment.  # noqa: E501

    OpenAPI spec version: v1
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


import pprint
import re  # noqa: F401

import six


class AvailableSensor(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    """

    """
    Attributes:
      swagger_types (dict): The key is attribute name
                            and the value is attribute type.
      attribute_map (dict): The key is attribute name
                            and the value is json key in definition.
    """
    swagger_types = {
        'sensor_type': 'str',
        'telegram_protocol': 'str',
        'telegram_timeout': 'int',
        'has_offset': 'int',
        'has_rotation': 'int',
        'available_telegrams': 'list[str]'
    }

    attribute_map = {
        'sensor_type': 'sensor-type',
        'telegram_protocol': 'telegram-protocol',
        'telegram_timeout': 'telegram-timeout',
        'has_offset': 'has-offset',
        'has_rotation': 'has-rotation',
        'available_telegrams': 'available-telegrams'
    }

    def __init__(self, sensor_type=None, telegram_protocol=None, telegram_timeout=None, has_offset=None, has_rotation=None, available_telegrams=None):  # noqa: E501
        """AvailableSensor - a model defined in Swagger"""  # noqa: E501

        self._sensor_type = None
        self._telegram_protocol = None
        self._telegram_timeout = None
        self._has_offset = None
        self._has_rotation = None
        self._available_telegrams = None
        self.discriminator = None

        if sensor_type is not None:
            self.sensor_type = sensor_type
        if telegram_protocol is not None:
            self.telegram_protocol = telegram_protocol
        if telegram_timeout is not None:
            self.telegram_timeout = telegram_timeout
        if has_offset is not None:
            self.has_offset = has_offset
        if has_rotation is not None:
            self.has_rotation = has_rotation
        if available_telegrams is not None:
            self.available_telegrams = available_telegrams

    @property
    def sensor_type(self):
        """Gets the sensor_type of this AvailableSensor.  # noqa: E501


        :return: The sensor_type of this AvailableSensor.  # noqa: E501
        :rtype: str
        """
        return self._sensor_type

    @sensor_type.setter
    def sensor_type(self, sensor_type):
        """Sets the sensor_type of this AvailableSensor.


        :param sensor_type: The sensor_type of this AvailableSensor.  # noqa: E501
        :type: str
        """

        self._sensor_type = sensor_type

    @property
    def telegram_protocol(self):
        """Gets the telegram_protocol of this AvailableSensor.  # noqa: E501


        :return: The telegram_protocol of this AvailableSensor.  # noqa: E501
        :rtype: str
        """
        return self._telegram_protocol

    @telegram_protocol.setter
    def telegram_protocol(self, telegram_protocol):
        """Sets the telegram_protocol of this AvailableSensor.


        :param telegram_protocol: The telegram_protocol of this AvailableSensor.  # noqa: E501
        :type: str
        """

        self._telegram_protocol = telegram_protocol

    @property
    def telegram_timeout(self):
        """Gets the telegram_timeout of this AvailableSensor.  # noqa: E501


        :return: The telegram_timeout of this AvailableSensor.  # noqa: E501
        :rtype: int
        """
        return self._telegram_timeout

    @telegram_timeout.setter
    def telegram_timeout(self, telegram_timeout):
        """Sets the telegram_timeout of this AvailableSensor.


        :param telegram_timeout: The telegram_timeout of this AvailableSensor.  # noqa: E501
        :type: int
        """

        self._telegram_timeout = telegram_timeout

    @property
    def has_offset(self):
        """Gets the has_offset of this AvailableSensor.  # noqa: E501


        :return: The has_offset of this AvailableSensor.  # noqa: E501
        :rtype: int
        """
        return self._has_offset

    @has_offset.setter
    def has_offset(self, has_offset):
        """Sets the has_offset of this AvailableSensor.


        :param has_offset: The has_offset of this AvailableSensor.  # noqa: E501
        :type: int
        """

        self._has_offset = has_offset

    @property
    def has_rotation(self):
        """Gets the has_rotation of this AvailableSensor.  # noqa: E501


        :return: The has_rotation of this AvailableSensor.  # noqa: E501
        :rtype: int
        """
        return self._has_rotation

    @has_rotation.setter
    def has_rotation(self, has_rotation):
        """Sets the has_rotation of this AvailableSensor.


        :param has_rotation: The has_rotation of this AvailableSensor.  # noqa: E501
        :type: int
        """

        self._has_rotation = has_rotation

    @property
    def available_telegrams(self):
        """Gets the available_telegrams of this AvailableSensor.  # noqa: E501


        :return: The available_telegrams of this AvailableSensor.  # noqa: E501
        :rtype: list[str]
        """
        return self._available_telegrams

    @available_telegrams.setter
    def available_telegrams(self, available_telegrams):
        """Sets the available_telegrams of this AvailableSensor.


        :param available_telegrams: The available_telegrams of this AvailableSensor.  # noqa: E501
        :type: list[str]
        """

        self._available_telegrams = available_telegrams

    def to_dict(self):
        """Returns the model properties as a dict"""
        result = {}

        for attr, _ in six.iteritems(self.swagger_types):
            value = getattr(self, attr)
            if isinstance(value, list):
                result[attr] = list(map(
                    lambda x: x.to_dict() if hasattr(x, "to_dict") else x,
                    value
                ))
            elif hasattr(value, "to_dict"):
                result[attr] = value.to_dict()
            elif isinstance(value, dict):
                result[attr] = dict(map(
                    lambda item: (item[0], item[1].to_dict())
                    if hasattr(item[1], "to_dict") else item,
                    value.items()
                ))
            else:
                result[attr] = value
        if issubclass(AvailableSensor, dict):
            for key, value in self.items():
                result[key] = value

        return result

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, AvailableSensor):
            return False

        return self.__dict__ == other.__dict__

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other
